import fs from "fs";
import path from "path";

/**
 * Cleanup temporary test circuit files generated by circom_tester
 * @param circuitNames - Array of circuit names (without extension) to clean up
 */
export function cleanupTestCircuits(circuitNames: string[]): void {
    const buildDir = path.join(__dirname, "..", "build");

    for (const circuitName of circuitNames) {
        // Remove .circom file
        const circomPath = path.join(buildDir, `${circuitName}.circom`);
        if (fs.existsSync(circomPath)) {
            fs.unlinkSync(circomPath);
        }

        // Remove .r1cs file
        const r1csPath = path.join(buildDir, `${circuitName}.r1cs`);
        if (fs.existsSync(r1csPath)) {
            fs.unlinkSync(r1csPath);
        }

        // Remove .sym file
        const symPath = path.join(buildDir, `${circuitName}.sym`);
        if (fs.existsSync(symPath)) {
            fs.unlinkSync(symPath);
        }

        // Remove _js directory
        const jsDir = path.join(buildDir, `${circuitName}_js`);
        if (fs.existsSync(jsDir)) {
            fs.rmSync(jsDir, { recursive: true, force: true });
        }
    }
}

/**
 * Cleanup all test circuit files matching the pattern test_*
 */
export function cleanupAllTestCircuits(): void {
    const buildDir = path.join(__dirname, "..", "build");

    if (!fs.existsSync(buildDir)) {
        return;
    }

    const files = fs.readdirSync(buildDir);
    const testCircuits = new Set<string>();

    // Find all test circuit base names
    for (const file of files) {
        if (file.startsWith("test_")) {
            // Extract base name without extension
            const baseName = file.replace(/\.(circom|r1cs|sym)$/, "").replace(/_js$/, "");
            testCircuits.add(baseName);
        }
    }

    // Cleanup all found test circuits
    cleanupTestCircuits(Array.from(testCircuits));
}
